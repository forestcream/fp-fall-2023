
-------------------------------------------------------------------------------

-- 1. Какие из выражений ниже находятся в слабой головной нормальной форме (WHNF),
--    но не в номальной форме (NF)? Почему? (1,5 балла)

-- Подсказка: выражение undefined находится не в NF:
--            оно может быть вычислено до прерывания программы с сообщением "*** Exception: Prelude.undefined"

    -- (+) (2 * 3 * 4) - это WHNF, так как содержит невычисленные выражения

    -- [undefined, 4 + 5, -1] - WHNF, так как undefined невычеслен

    -- (,) undefined - WHNF, из-за undefined

    -- 3 - NF, ничего вычислять не нужно

    -- fst (1,0) - NF, может быть полностью вычислено

    -- \x -> x - NF, может быть полностью вычислено

-------------------------------------------------------------------------------

-- 2. Распишите вычисление `value` в thunk'ах (1 балл)

value :: Integer
value = foo (3 * 10) (5 - 2)
  where
    foo :: Num p => p -> p -> p
    foo a b = bar a a (a + b)

    bar :: Num a => a -> a -> p -> a
    bar x y z = x + y
-- <thunk: (<thunk: 3> * <thunk: 10>)>  (3 * 10)
-- <thunk: (<thunk: 5> - <thunk: 2>)> (5-2)
-- 1 step
-- <thunk: <thunk: foo <thunk: <thunk: (<thunk: 3> * <thunk: 10>)> <thunk: (<thunk: 5> - <thunk: 2>)>>>>

-- 2 step
-- <thunk: <thunk: bar <thunk: <thunk: (<thunk: 3> * <thunk: 10>)> <thunk: (<thunk: 3> * <thunk: 10>)> <thunk: <thunk: (<thunk: 3> * <thunk: 10>)> + <thunk: (<thunk: 5> - <thunk: 2>)>>>>>

-- 3 step
-- <thunk: <thunk: bar <thunk: <thunk: <thunk: (<thunk: 3> * <thunk: 10>)> + <thunk: (<thunk: 3> * <thunk: 10>)>>>>>

-- 4 step
-- <thunk: <thunk: bar <thunk: <thunk: <thunk: (3 * 10)> + <thunk: (3 * 10)>>>>>

-- 5 step
-- <thunk: <thunk: bar <thunk: <thunk: <thunk: (30)> + <thunk: (30)>>>>>

-- 6 step
-- <thunk: <thunk: bar <thunk: <thunk: 30 + 30 >>>>

-- 7 step
-- <thunk: <thunk: bar <thunk: <thunk: 60 >>>>

-- 8 step
-- <thunk: <thunk: bar <thunk: 60>>>

-- 9 step
-- <thunk: <thunk: 60>>

-- 10 step
-- <thunk: 60>

-- 11 step
-- 60
-------------------------------------------------------------------------------

-- 3. Какие из нижеперечисленных функций не могут привести к расходимости (неостановке вычисления)? Почему? (2 балла)

-- может привести к расходимости, если подать на вход бесконечный список, так как это список будет пытаться вычислиться
wow :: p -> p
wow a = a

-- не может, так как мы на вход подаем строго целые числа, и не получится сделать бесконечные вычисления
con :: b -> Integer -> Integer -> Integer
con = const foo

-- не может, так как нам не нужно вычислять нигде агрументы, мы прсто возвращаем True
bazz :: p -> b -> Bool
bazz x = const True

-- может, при чем всегда будет виснуть. Это происходит так как мы пытаемся вычислить x через самого себя и зацикливаемся
qux :: t
qux = let x = x in x

-- не может, эта функция не принимает аргументов и возвращает просто всегда одну и ту же строку
corge :: String
corge = "Sorry, my value was changed"

-- видно, не может, у меня при вызове на бесконечных списках вылетала ошибка
-- возможно это связано с ограничением Num
grault :: (Eq a, Num a) => p -> a -> p
grault x 0 = x
grault x y = x

-- так же не может, все время возвращает 'q'
garply :: Integer -> Char
garply = grault 'q'

-- не может, вызываемся только на числах
waldo :: Integer -> Integer -> Integer
waldo = foo

-------------------------------------------------------------------------------

-- 4. BangPatterns  (0,5 балла)
--    Реализуйте `foldl'`, форсировав вычисление с помощью ! аналогично `sumBang` из лекции

foldl' :: (b -> a -> b) -> b -> [a] -> b
foldl' f z xs = go xs z
  where
    go []     !acc = acc
    go (x:xs) !acc = go xs (f acc x)

-------------------------------------------------------------------------------

-- 5. `seq` (2 балла)

-- Помимо ! есть и другие способы форсировать вычисление.
-- Например, если вы хотите вычислить значение перед передачей его в функцию, можно использовать `seq` 
-- https://hackage.haskell.org/package/ghc-prim-0.11.0/docs/GHC-Prim.html#v:seq

-- `seq` принимает 2 аргумента, вычисляет первый до WHNF и возвращает второй

-- Как использовать? Пример с foldl':
-- https://hackage.haskell.org/package/base-4.19.0.0/docs/src/Data.Foldable.html#foldl%27
-- Здесь есть следующий код: z `seq` k (f z x).
-- В этом случае первый аргумент `seq` -- z, и z будет вычислено до WHNF,
-- а затем он будет использоватся при вычислении второго аргумента -- k (f z x).
-- Результат вычисления второго аргумента -- результат всего `seq`

-- Практикуемся: rде поможет seq?
-- При вычислении каких из перечисленных ниже функций использование seq предотвратит
-- нарастание количества невычисленных выражений при увеличении значения первого аргумента?
-- Объясните свой ответ

foo :: (Eq a, Num a, Num t) => a -> t -> t
foo 0 x = x
foo n x = let x' = foo (n - 1) (x + 1)
          in x' `seq` x' -- вот тут будет форсироватьсся вычисление х
-- с seq n = 3 x = 0
-- foo 3 0  -> foo 2 1 -> 1 2 -> 0 3 -возвращаем 3
-- я так понимаю, что так как паттерн матрчинг зависит от n, то без seq мы и будем только его считать до последнего,
-- откладывая х, что приведет к накоплению вычислений х. а с seq, мы заставляем х вычисляться по ходу, из-за чего
-- стек не переполниться

bar :: (Eq t1, Num t1) => t1 -> (t1 -> t2) -> t1 -> t2
bar 0 f = f
bar x f = let f' = \a -> f (x + a)
              x' = x - 1
          in f' `seq` x' `seq` bar x' f'

-- с seq x = 3, f = id, a = 0
-- bar 3 id 0 -> 
    -- f' = \a -> id (3 + a) = 3
    -- x' = 3 - 1 = 2
-- bar 2 f' 0 ->
    -- f'' = \a -> f' (2 + a) = \a -> id (2 + (2 + a)) = 4
    -- x'' = 2 - 1 = 1
-- bar 1 f'' 0 ->
    -- f''' = \a -> f'' (1 + a) = \a -> id (1 + (1 + a)) = 2
    -- x''' = 1 - 1 = 0
-- bar 0 f''' 0 - возвращаем 2
-- без seq вычисления всех f' откладывались и накапливались, а так seq заставляет вычислить на каждом шаге

baz :: (Eq t, Num t, Num a) => t -> (a, a) -> a
baz 0 (x, y) = x + y
baz n (x, y) = let x' = x + 1
                   y' = y - 1
                   p  = (x', y')
                   n' = n - 1
               in p `seq` n' `seq` baz n' p

-- n = 3, (x,y) = (0, 0)
-- baz 3 (0, 0) ->
    -- x' = 0 + 1 = 1
    -- y' = 0 - 1 = -1
    -- p = (1, -1)
    -- n' = 2
-- baz 2 (1, -1) ->
    -- x' = 1 + 1 = 2
    -- y' = -1 - 1 = -2
    -- p = (2, -2)
    -- n' = 2 - 1 = 1
-- baz 1 (2, -2) ->
    -- x' = 2 + 1 = 3
    -- y' = -2 - 1 = -3
    -- p = (3, -3)
    -- n' = 1 - 1 = 0
-- baz 0 (3, -3) - возвращаем 0
-- мы заставляем вычислить p и n перед тем, как вызвать рекурсивно функцию, что тоже не дает накапливать стэк вычислений

quux :: (Eq t, Num t, Num a) => t -> (a, a) -> a
quux 0 (x, y) = x + y
quux n (x, y) = let x' = x + 1
                    y' = y - 1
                    p  = (x', y')
                    n' = n - 1
                in x' `seq` y' `seq` n' `seq` quux n' p

-- n = 3, (x, y) = (0, 0)
-- quux 3 (0, 0) ->
    -- x' = 0 + 1 = 1
    -- y' = 0 - 1 = -1
    -- p = (1, -1)
    -- n' = 3 - 1 = 2
-- quux 2 (1, -1) ->
    -- x' = 1 + 1 = 2
    -- y' = -1 - 1 = -2
    -- p = (2, -2)
    -- n' = 2 - 1 = 1
-- quux 1 (2, -2) ->
    -- x' = 2 + 1 = 3
    -- y' = -2 - 1 = -3
    -- p = (3, -3)
    -- n' = 1 - 1 = 0
-- quux 0 (3, -3) -> возвращаем 0
-- тоже самое, что ы предыдущем примере, мы заставляем вычислить все переменные, до того как они уйдут в рекурсию, то есть у нас не бдует накапливаться стэк

-------------------------------------------------------------------------------

-- 6. $! (1 балл)

-- Вдобавок к ! и `seq` есть $!. Он нужен, чтобы вычислить значение перед передачей его в функцию.
-- Несложно заметить, что он напоминает $ -- оператор применения.
-- $! -- строгую версию $, вычисляющую аргумент до WHNF перед передачей его в функцию

-- Ниже определены функции mySum и goSum. Ответьте на вопросы об их вычислении

mySum :: (Eq a, Num a) => (a, ()) -> a -> (a, ())
mySum acc 0 = acc
-- 6.a Почему Haskell говорит здесь, что $! -- redundant?
-- потому что у нас и так рекурсивный вывод, ради которого нужно вычислить аргументы, которые передать дальше
-- и избыточно заставлять его так делать
mySum (result, ()) n = (mySum $! (result + n, ())) $ n - 1

goSum :: Integer -> (Integer, ())
goSum = mySum (0, ())

-- 6.b Будут ли накапливаться отложенные вычисления в первом аргументе функции mySum?
--    Да или нет и почему?
-- нет, они будут вычисляться на каждом шаге, так как мы передаем в рекурсивный вызов уже result + n
-- и ему надо вычислиться

-- 6.c Будут ли накапливаться отложенные вычисления во втором аргументе функции mySum?
--    Да или нет и почему?
-- да, будут, так как нам нужен результат n, только в конце  и пока он не потребуется, вычисления будут откладываться

-------------------------------------------------------------------------------

-- 7*. Почему здесь происходит утечка памяти? Как ее исправить? (2 балла)

-- let small' = fst (small, large) in ... small' ...
-- есть в large будет лежать что-то большое, то мы получается просто так таскаем за собой что-то большое,
-- но при этом не используем его
-- исправить можно просто используя не кортеж, а все по отдельности
-------------------------------------------------------------------------------
